diff --git a/gfx/layers/ipc/AsyncPanZoomController.cpp b/gfx/layers/ipc/AsyncPanZoomController.cpp
index 623107b..d721445 100644
--- a/gfx/layers/ipc/AsyncPanZoomController.cpp
+++ b/gfx/layers/ipc/AsyncPanZoomController.cpp
@@ -539,16 +539,17 @@ nsEventStatus AsyncPanZoomController::ReceiveInputEvent(const InputData& aEvent)
 nsEventStatus AsyncPanZoomController::HandleInputEvent(const InputData& aEvent) {
   nsEventStatus rv = nsEventStatus_eIgnore;
 
-  nsRefPtr<GestureEventListener> listener = GetGestureEventListener();
-  if (listener) {
-    rv = listener->HandleInputEvent(aEvent);
-    if (rv == nsEventStatus_eConsumeNoDefault)
-      return rv;
-  }
-
   switch (aEvent.mInputType) {
   case MULTITOUCH_INPUT: {
     const MultiTouchInput& multiTouchInput = aEvent.AsMultiTouchInput();
+
+    nsRefPtr<GestureEventListener> listener = GetGestureEventListener();
+    if (listener) {
+      rv = listener->HandleInputEvent(multiTouchInput);
+      if (rv == nsEventStatus_eConsumeNoDefault)
+        return rv;
+    }
+
     switch (multiTouchInput.mType) {
       case MultiTouchInput::MULTITOUCH_START: rv = OnTouchStart(multiTouchInput); break;
       case MultiTouchInput::MULTITOUCH_MOVE: rv = OnTouchMove(multiTouchInput); break;
@@ -558,6 +559,18 @@ nsEventStatus AsyncPanZoomController::HandleInputEvent(const InputData& aEvent)
     }
     break;
   }
+  default: NS_WARNING("Unhandled input event"); break;
+  }
+
+  mLastEventTime = aEvent.mTime;
+  return rv;
+}
+
+nsEventStatus AsyncPanZoomController::HandleGestureEvent(const InputData& aEvent)
+{
+  nsEventStatus rv = nsEventStatus_eIgnore;
+
+  switch (aEvent.mInputType) {
   case PINCHGESTURE_INPUT: {
     const PinchGestureInput& pinchGestureInput = aEvent.AsPinchGestureInput();
     switch (pinchGestureInput.mType) {
diff --git a/gfx/layers/ipc/AsyncPanZoomController.h b/gfx/layers/ipc/AsyncPanZoomController.h
index ff449ac..7875c36 100644
--- a/gfx/layers/ipc/AsyncPanZoomController.h
+++ b/gfx/layers/ipc/AsyncPanZoomController.h
@@ -256,6 +256,15 @@ public:
   nsEventStatus HandleInputEvent(const InputData& aEvent);
 
   /**
+   * Handler for gesture events.
+   * Currently some gestures are detected in GestureEventListener that calls
+   * APZC back through this handler in order to avoid recursive calls to
+   * APZC::HandleInputEvent() which is supposed to do the work for
+   * ReceiveInputEvent().
+   */
+  nsEventStatus HandleGestureEvent(const InputData& aEvent);
+
+  /**
    * Populates the provided object (if non-null) with the scrollable guid of this apzc.
    */
   void GetGuid(ScrollableLayerGuid* aGuidOut);
diff --git a/gfx/layers/ipc/GestureEventListener.cpp b/gfx/layers/ipc/GestureEventListener.cpp
index a822ce7..c4fcbca 100644
--- a/gfx/layers/ipc/GestureEventListener.cpp
+++ b/gfx/layers/ipc/GestureEventListener.cpp
@@ -8,12 +8,9 @@
 #include <math.h>                       // for fabsf
 #include <stddef.h>                     // for size_t
 #include "AsyncPanZoomController.h"     // for AsyncPanZoomController
-#include "mozilla/layers/APZCTreeManager.h"  // for APZCTreeManager
 #include "base/task.h"                  // for CancelableTask, etc
 #include "mozilla/Preferences.h"        // for Preferences
-#include "mozilla/gfx/BasePoint.h"      // for BasePoint
-#include "mozilla/mozalloc.h"           // for operator new
-#include "nsDebug.h"                    // for NS_WARN_IF_FALSE
+#include "nsDebug.h"                    // for NS_WARNING
 #include "nsMathUtils.h"                // for NS_hypot
 
 namespace mozilla {
@@ -34,12 +31,26 @@ static const uint32_t MAX_TAP_TIME = 300;
  */
 static const float PINCH_START_THRESHOLD = 35.0f;
 
+ScreenPoint GetCurrentFocus(const MultiTouchInput& aEvent)
+{
+  const ScreenIntPoint& firstTouch = aEvent.mTouches[0].mScreenPoint,
+                       secondTouch = aEvent.mTouches[1].mScreenPoint;
+  return ScreenPoint(firstTouch + secondTouch) / 2;
+}
+
+float GetCurrentSpan(const MultiTouchInput& aEvent)
+{
+  const ScreenIntPoint& firstTouch = aEvent.mTouches[0].mScreenPoint,
+                       secondTouch = aEvent.mTouches[1].mScreenPoint;
+  ScreenIntPoint delta = secondTouch - firstTouch;
+  return float(NS_hypot(delta.x, delta.y));
+}
+
 GestureEventListener::GestureEventListener(AsyncPanZoomController* aAsyncPanZoomController)
   : mAsyncPanZoomController(aAsyncPanZoomController),
     mState(GESTURE_NONE),
     mSpanChange(0.0f),
-    mTapStartTime(0),
-    mLastTapEndTime(0),
+    mPreviousSpan(0.0f),
     mLastTouchInput(MultiTouchInput::MULTITOUCH_START, 0, 0)
 {
 }
@@ -48,360 +59,403 @@ GestureEventListener::~GestureEventListener()
 {
 }
 
-nsEventStatus GestureEventListener::HandleInputEvent(const InputData& aEvent)
+nsEventStatus GestureEventListener::HandleInputEvent(const MultiTouchInput& aEvent)
 {
-  if (aEvent.mInputType != MULTITOUCH_INPUT) {
-    return nsEventStatus_eIgnore;
-  }
-
-  const MultiTouchInput& event = static_cast<const MultiTouchInput&>(aEvent);
+  nsEventStatus rv = nsEventStatus_eIgnore;
 
   // Cache the current event since it may become the single or long tap that we
   // send.
-  mLastTouchInput = event;
+  mLastTouchInput = aEvent;
 
-  switch (event.mType)
-  {
+  switch (aEvent.mType) {
   case MultiTouchInput::MULTITOUCH_START:
-  case MultiTouchInput::MULTITOUCH_ENTER: {
-    for (size_t i = 0; i < event.mTouches.Length(); i++) {
-      bool foundAlreadyExistingTouch = false;
-      for (size_t j = 0; j < mTouches.Length(); j++) {
-        if (mTouches[j].mIdentifier == event.mTouches[i].mIdentifier) {
-          foundAlreadyExistingTouch = true;
-          break;
-        }
-      }
-
-      // If we didn't find a touch in our list that matches this, then add it.
-      if (!foundAlreadyExistingTouch) {
-        mTouches.AppendElement(event.mTouches[i]);
-      }
+  case MultiTouchInput::MULTITOUCH_ENTER:
+    mTouches.Clear();
+    for (size_t i = 0; i < aEvent.mTouches.Length(); i++) {
+      mTouches.AppendElement(aEvent.mTouches[i]);
     }
 
-    size_t length = mTouches.Length();
-    if (length == 1) {
-      mTapStartTime = event.mTime;
-      mTouchStartPosition = event.mTouches[0].mScreenPoint;
-      if (mState == GESTURE_NONE) {
-        mState = GESTURE_WAITING_SINGLE_TAP;
-
-        mLongTapTimeoutTask =
-          NewRunnableMethod(this, &GestureEventListener::TimeoutLongTap);
-
-        mAsyncPanZoomController->PostDelayedTask(
-          mLongTapTimeoutTask,
-          Preferences::GetInt("ui.click_hold_context_menus.delay", 500));
-      }
-    } else if (length == 2) {
-      // Another finger has been added; it can't be a tap anymore.
-      HandleTapCancel(event);
+    if (aEvent.mTouches.Length() == 1) {
+      rv = HandleInputTouchSingleStart();
+    } else {
+      rv = HandleInputTouchMultiStart();
     }
-
     break;
-  }
-  case MultiTouchInput::MULTITOUCH_MOVE: {
-    // If we move too much, bail out of the tap.
-    ScreenIntPoint delta = event.mTouches[0].mScreenPoint - mTouchStartPosition;
-    if (mTouches.Length() == 1 &&
-        NS_hypot(delta.x, delta.y) > AsyncPanZoomController::GetTouchStartTolerance())
-    {
-      HandleTapCancel(event);
-    }
-
-    size_t eventTouchesMatched = 0;
-    for (size_t i = 0; i < mTouches.Length(); i++) {
-      bool isTouchRemoved = true;
-      for (size_t j = 0; j < event.mTouches.Length(); j++) {
-        if (mTouches[i].mIdentifier == event.mTouches[j].mIdentifier) {
-          eventTouchesMatched++;
-          isTouchRemoved = false;
-          mTouches[i] = event.mTouches[j];
-        }
-      }
-      if (isTouchRemoved) {
-        // this touch point was lifted, so remove it from our list
-        mTouches.RemoveElementAt(i);
-        i--;
-      }
-    }
-
-    NS_WARN_IF_FALSE(eventTouchesMatched == event.mTouches.Length(), "Touch moved, but not in list");
-
+  case MultiTouchInput::MULTITOUCH_MOVE:
+    rv = HandleInputTouchMove();
     break;
-  }
   case MultiTouchInput::MULTITOUCH_END:
-  case MultiTouchInput::MULTITOUCH_LEAVE: {
-    for (size_t i = 0; i < event.mTouches.Length(); i++) {
-      bool foundAlreadyExistingTouch = false;
-      for (size_t j = 0; j < mTouches.Length() && !foundAlreadyExistingTouch; j++) {
-        if (event.mTouches[i].mIdentifier == mTouches[j].mIdentifier) {
-          foundAlreadyExistingTouch = true;
+  case MultiTouchInput::MULTITOUCH_LEAVE:
+    for (size_t i = 0; i < aEvent.mTouches.Length(); i++) {
+      for (size_t j = 0; j < mTouches.Length(); j++) {
+        if (aEvent.mTouches[i].mIdentifier == mTouches[j].mIdentifier) {
           mTouches.RemoveElementAt(j);
+          break;
         }
       }
-      NS_WARN_IF_FALSE(foundAlreadyExistingTouch, "Touch ended, but not in list");
     }
 
-    if (mState == GESTURE_WAITING_DOUBLE_TAP) {
-      CancelDoubleTapTimeoutTask();
-      if (mTapStartTime - mLastTapEndTime > MAX_TAP_TIME ||
-          event.mTime - mTapStartTime > MAX_TAP_TIME) {
-        // Either the time between taps or the last tap took too long
-        // confirm previous tap and handle current tap seperately
-        TimeoutDoubleTap();
-        mState = GESTURE_WAITING_SINGLE_TAP;
-      } else {
-        // We were waiting for a double tap and it has arrived.
-        HandleDoubleTap(event);
-        mState = GESTURE_NONE;
-      }
-    }
-
-    if (mState == GESTURE_LONG_TAP_UP) {
-      HandleLongTapUpEvent(event);
-      mState = GESTURE_NONE;
-    } else if (mState == GESTURE_WAITING_SINGLE_TAP &&
-        event.mTime - mTapStartTime > MAX_TAP_TIME) {
-      // Extended taps are immediately dispatched as single taps
-      CancelLongTapTimeoutTask();
-      HandleSingleTapConfirmedEvent(event);
-      mState = GESTURE_NONE;
-    } else if (mState == GESTURE_WAITING_SINGLE_TAP) {
-      CancelLongTapTimeoutTask();
-      nsEventStatus tapupEvent = HandleSingleTapUpEvent(event);
-
-      if (tapupEvent == nsEventStatus_eIgnore) {
-        // We were not waiting for anything but a single tap has happened that
-        // may turn into a double tap. Wait a while and if it doesn't turn into
-        // a double tap, send a single tap instead.
-        mState = GESTURE_WAITING_DOUBLE_TAP;
+    rv = HandleInputTouchEnd();
+    break;
+  case MultiTouchInput::MULTITOUCH_CANCEL:
+    mTouches.Clear();
+    rv = HandleInputTouchCancel();
+    break;
+  }
 
-        mDoubleTapTimeoutTask =
-          NewRunnableMethod(this, &GestureEventListener::TimeoutDoubleTap);
+  return rv;
+}
 
-        mAsyncPanZoomController->PostDelayedTask(
-          mDoubleTapTimeoutTask,
-          MAX_TAP_TIME);
+nsEventStatus GestureEventListener::HandleInputTouchSingleStart()
+{
+  switch (mState) {
+  case GESTURE_NONE:
+    SetState(GESTURE_FIRST_SINGLE_TOUCH_DOWN);
+    mTouchStartPosition = mLastTouchInput.mTouches[0].mScreenPoint;
 
-      } else if (tapupEvent == nsEventStatus_eConsumeNoDefault) {
-        // We sent the tapup into content without waiting for a double tap
-        mState = GESTURE_NONE;
-      }
-    }
+    CreateLongTapTimeoutTask();
+    CreateMaxTapTimeoutTask();
+    break;
+  case GESTURE_FIRST_SINGLE_TOUCH_UP:
+    SetState(GESTURE_SECOND_SINGLE_TOUCH_DOWN);
+    break;
+  default:
+    NS_WARNING("Unhandled state upon single touch start");
+    SetState(GESTURE_NONE);
+    break;
+  }
 
-    mLastTapEndTime = event.mTime;
+  return nsEventStatus_eIgnore;
+}
 
-    if (!mTouches.Length()) {
-      mSpanChange = 0.0f;
-    }
+nsEventStatus GestureEventListener::HandleInputTouchMultiStart()
+{
+  nsEventStatus rv = nsEventStatus_eIgnore;
 
+  switch (mState) {
+  case GESTURE_NONE:
+    SetState(GESTURE_MULTI_TOUCH_DOWN);
+    break;
+  case GESTURE_FIRST_SINGLE_TOUCH_DOWN:
+    CancelLongTapTimeoutTask();
+    CancelMaxTapTimeoutTask();
+    SetState(GESTURE_MULTI_TOUCH_DOWN);
+    // Prevent APZC::OnTouchStart() from handling MULTITOUCH_START event
+    rv = nsEventStatus_eConsumeNoDefault;
+    break;
+  case GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN:
+    CancelLongTapTimeoutTask();
+    SetState(GESTURE_MULTI_TOUCH_DOWN);
+    // Prevent APZC::OnTouchStart() from handling MULTITOUCH_START event
+    rv = nsEventStatus_eConsumeNoDefault;
+    break;
+  case GESTURE_FIRST_SINGLE_TOUCH_UP:
+    // Cancel wait for double tap
+    CancelMaxTapTimeoutTask();
+    SetState(GESTURE_MULTI_TOUCH_DOWN);
+    // Prevent APZC::OnTouchStart() from handling MULTITOUCH_START event
+    rv = nsEventStatus_eConsumeNoDefault;
+    break;
+  case GESTURE_SECOND_SINGLE_TOUCH_DOWN:
+    // Cancel wait for single tap
+    CancelMaxTapTimeoutTask();
+    SetState(GESTURE_MULTI_TOUCH_DOWN);
+    // Prevent APZC::OnTouchStart() from handling MULTITOUCH_START event
+    rv = nsEventStatus_eConsumeNoDefault;
+    break;
+  case GESTURE_LONG_TOUCH_DOWN:
+    SetState(GESTURE_MULTI_TOUCH_DOWN);
+    break;
+  case GESTURE_MULTI_TOUCH_DOWN:
+  case GESTURE_PINCH:
+    // Prevent APZC::OnTouchStart() from handling MULTITOUCH_START event
+    rv = nsEventStatus_eConsumeNoDefault;
+    break;
+  default:
+    NS_WARNING("Unhandled state upon multitouch start");
+    SetState(GESTURE_NONE);
     break;
-  }
-  case MultiTouchInput::MULTITOUCH_CANCEL:
-    // This gets called if there's a touch that has to bail for weird reasons
-    // like pinching and then moving away from the window that the pinch was
-    // started in without letting go of the screen.
-    return HandlePinchGestureEvent(event, true);
   }
 
-  return HandlePinchGestureEvent(event, false);
+  return rv;
 }
 
-nsEventStatus GestureEventListener::HandlePinchGestureEvent(const MultiTouchInput& aEvent, bool aClearTouches)
+nsEventStatus GestureEventListener::HandleInputTouchMove()
 {
   nsEventStatus rv = nsEventStatus_eIgnore;
 
-  if (mTouches.Length() > 1 && !aClearTouches) {
-    const ScreenIntPoint& firstTouch = mTouches[0].mScreenPoint,
-                         secondTouch = mTouches[1].mScreenPoint;
-    ScreenPoint focusPoint = ScreenPoint(firstTouch + secondTouch) / 2;
-    ScreenIntPoint delta = secondTouch - firstTouch;
-    float currentSpan = float(NS_hypot(delta.x, delta.y));
-
-    switch (mState) {
-    case GESTURE_NONE:
-      mPreviousSpan = currentSpan;
-      mState = GESTURE_WAITING_PINCH;
-      // Deliberately fall through. If the user pinched and took their fingers
-      // off the screen such that they still had 1 left on it, we want there to
-      // be no resistance. We should only reset |mSpanChange| once all fingers
-      // are off the screen.
-    case GESTURE_WAITING_PINCH: {
-      mSpanChange += fabsf(currentSpan - mPreviousSpan);
-      if (mSpanChange > PINCH_START_THRESHOLD) {
-        PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_START,
-                                     aEvent.mTime,
-                                     focusPoint,
-                                     currentSpan,
-                                     currentSpan,
-                                     aEvent.modifiers);
-
-        mAsyncPanZoomController->HandleInputEvent(pinchEvent);
-
-        mState = GESTURE_PINCH;
-      }
+  switch (mState) {
+  case GESTURE_NONE:
+  case GESTURE_LONG_TOUCH_DOWN:
+    // Ignore this input signal as the corresponding events get handled by APZC
+    break;
+
+  case GESTURE_FIRST_SINGLE_TOUCH_DOWN:
+  case GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN:
+  case GESTURE_SECOND_SINGLE_TOUCH_DOWN: {
+    // If we move too much, bail out of the tap.
+    ScreenIntPoint delta = mLastTouchInput.mTouches[0].mScreenPoint - mTouchStartPosition;
+    if (NS_hypot(delta.x, delta.y) > AsyncPanZoomController::GetTouchStartTolerance()) {
+      CancelLongTapTimeoutTask();
+      CancelMaxTapTimeoutTask();
+      SetState(GESTURE_NONE);
+    }
+    break;
+  }
 
+  case GESTURE_MULTI_TOUCH_DOWN: {
+    if (mLastTouchInput.mTouches.Length() < 2) {
+      NS_WARNING("Wrong input: less than 2 moving points in GESTURE_MULTI_TOUCH_DOWN state");
       break;
     }
-    case GESTURE_PINCH: {
-      PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_SCALE,
-                                   aEvent.mTime,
-                                   focusPoint,
+
+    float currentSpan = GetCurrentSpan(mLastTouchInput);
+
+    mSpanChange += fabsf(currentSpan - mPreviousSpan);
+    if (mSpanChange > PINCH_START_THRESHOLD) {
+      SetState(GESTURE_PINCH);
+      PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_START,
+                                   mLastTouchInput.mTime,
+                                   GetCurrentFocus(mLastTouchInput),
                                    currentSpan,
-                                   mPreviousSpan,
-                                   aEvent.modifiers);
+                                   currentSpan,
+                                   mLastTouchInput.modifiers);
 
-      mAsyncPanZoomController->HandleInputEvent(pinchEvent);
-      break;
+      mAsyncPanZoomController->HandleGestureEvent(pinchEvent);
     }
-    default:
-      // What?
+    rv = nsEventStatus_eConsumeNoDefault;
+    mPreviousSpan = currentSpan;
+    break;
+  }
+
+  case GESTURE_PINCH: {
+    if (mLastTouchInput.mTouches.Length() < 2) {
+      NS_WARNING("Wrong input: less than 2 moving points in GESTURE_PINCH state");
+      // Prevent APZC::OnTouchMove() from handling this wrong input
+      rv = nsEventStatus_eConsumeNoDefault;
       break;
     }
 
-    mPreviousSpan = currentSpan;
+    float currentSpan = GetCurrentSpan(mLastTouchInput);
 
-    rv = nsEventStatus_eConsumeNoDefault;
-  } else if (mState == GESTURE_PINCH) {
-    PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_END,
-                                 aEvent.mTime,
-                                 ScreenPoint(),
-                                 1.0f,
-                                 1.0f,
-                                 aEvent.modifiers);
-    mAsyncPanZoomController->HandleInputEvent(pinchEvent);
-
-    mState = GESTURE_NONE;
-
-    // If the user left a finger on the screen, spoof a touch start event and
-    // send it to APZC so that they can continue panning from that point.
-    if (mTouches.Length() == 1) {
-      MultiTouchInput touchEvent(MultiTouchInput::MULTITOUCH_START,
-                                 aEvent.mTime,
-                                 aEvent.modifiers);
-      touchEvent.mTouches.AppendElement(mTouches[0]);
-      mAsyncPanZoomController->HandleInputEvent(touchEvent);
-
-      // The spoofed touch start will get back to GEL and make us enter the
-      // GESTURE_WAITING_SINGLE_TAP state, but this isn't a new touch, so there
-      // is no condition under which this touch should turn into any tap.
-      mState = GESTURE_NONE;
-    }
+    PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_SCALE,
+                                 mLastTouchInput.mTime,
+                                 GetCurrentFocus(mLastTouchInput),
+                                 currentSpan,
+                                 mPreviousSpan,
+                                 mLastTouchInput.modifiers);
 
+    mAsyncPanZoomController->HandleGestureEvent(pinchEvent);
     rv = nsEventStatus_eConsumeNoDefault;
-  } else if (mState == GESTURE_WAITING_PINCH) {
-    mState = GESTURE_NONE;
+    mPreviousSpan = currentSpan;
+
+    break;
   }
 
-  if (aClearTouches) {
-    mTouches.Clear();
+  default:
+    NS_WARNING("Unhandled state upon touch move");
+    SetState(GESTURE_NONE);
+    break;
   }
 
   return rv;
 }
 
-nsEventStatus GestureEventListener::HandleSingleTapUpEvent(const MultiTouchInput& aEvent)
-{
-  TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_UP, aEvent.mTime,
-      aEvent.mTouches[0].mScreenPoint, aEvent.modifiers);
-  return mAsyncPanZoomController->HandleInputEvent(tapEvent);
-}
-
-nsEventStatus GestureEventListener::HandleSingleTapConfirmedEvent(const MultiTouchInput& aEvent)
+nsEventStatus GestureEventListener::HandleInputTouchEnd()
 {
-  TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_CONFIRMED, aEvent.mTime,
-      aEvent.mTouches[0].mScreenPoint, aEvent.modifiers);
-  return mAsyncPanZoomController->HandleInputEvent(tapEvent);
-}
+  nsEventStatus rv = nsEventStatus_eIgnore;
 
-nsEventStatus GestureEventListener::HandleLongTapEvent(const MultiTouchInput& aEvent)
-{
-  TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_LONG, aEvent.mTime,
-      aEvent.mTouches[0].mScreenPoint, aEvent.modifiers);
-  return mAsyncPanZoomController->HandleInputEvent(tapEvent);
-}
+  switch (mState) {
+  case GESTURE_NONE:
+    // GEL doesn't have a dedicated state for PANNING handled in APZC thus ignore.
+    break;
 
-nsEventStatus GestureEventListener::HandleLongTapUpEvent(const MultiTouchInput& aEvent)
-{
-  TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_LONG_UP, aEvent.mTime,
-      aEvent.mTouches[0].mScreenPoint, aEvent.modifiers);
-  return mAsyncPanZoomController->HandleInputEvent(tapEvent);
-}
+  case GESTURE_FIRST_SINGLE_TOUCH_DOWN: {
+    CancelLongTapTimeoutTask();
+    CancelMaxTapTimeoutTask();
+    TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_UP,
+                             mLastTouchInput.mTime,
+                             mLastTouchInput.mTouches[0].mScreenPoint,
+                             mLastTouchInput.modifiers);
+    nsEventStatus tapupStatus = mAsyncPanZoomController->HandleGestureEvent(tapEvent);
+    if (tapupStatus == nsEventStatus_eIgnore) {
+      SetState(GESTURE_FIRST_SINGLE_TOUCH_UP);
+      CreateMaxTapTimeoutTask();
+    } else {
+      // We sent the tapup into content without waiting for a double tap
+      SetState(GESTURE_NONE);
+    }
+    break;
+  }
 
-nsEventStatus GestureEventListener::HandleTapCancel(const MultiTouchInput& aEvent)
-{
-  mTapStartTime = 0;
+  case GESTURE_SECOND_SINGLE_TOUCH_DOWN: {
+    CancelMaxTapTimeoutTask();
+    SetState(GESTURE_NONE);
+    TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_DOUBLE,
+                             mLastTouchInput.mTime,
+                             mLastTouchInput.mTouches[0].mScreenPoint,
+                             mLastTouchInput.modifiers);
+    mAsyncPanZoomController->HandleGestureEvent(tapEvent);
+    break;
+  }
 
-  switch (mState)
-  {
-  case GESTURE_WAITING_SINGLE_TAP:
+  case GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN:
     CancelLongTapTimeoutTask();
-    mState = GESTURE_NONE;
+    SetState(GESTURE_NONE);
+    TriggerSingleTapConfirmedEvent();
     break;
 
-  case GESTURE_WAITING_DOUBLE_TAP:
-  case GESTURE_LONG_TAP_UP:
-    mState = GESTURE_NONE;
+  case GESTURE_LONG_TOUCH_DOWN: {
+    SetState(GESTURE_NONE);
+    TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_LONG_UP,
+                             mLastTouchInput.mTime,
+                             mLastTouchInput.mTouches[0].mScreenPoint,
+                             mLastTouchInput.modifiers);
+    mAsyncPanZoomController->HandleGestureEvent(tapEvent);
     break;
+  }
+
+  case GESTURE_MULTI_TOUCH_DOWN:
+    if (mTouches.Length() < 2) {
+      SetState(GESTURE_NONE);
+    }
+    break;
+
+  case GESTURE_PINCH:
+    if (mTouches.Length() < 2) {
+      SetState(GESTURE_NONE);
+      PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_END,
+                                   mLastTouchInput.mTime,
+                                   ScreenPoint(),
+                                   1.0f,
+                                   1.0f,
+                                   mLastTouchInput.modifiers);
+      mAsyncPanZoomController->HandleGestureEvent(pinchEvent);
+    }
+    rv = nsEventStatus_eConsumeNoDefault;
+    break;
+
   default:
+    NS_WARNING("Unhandled state upon touch end");
+    SetState(GESTURE_NONE);
     break;
   }
 
-  return nsEventStatus_eConsumeDoDefault;
+  return rv;
 }
 
-nsEventStatus GestureEventListener::HandleDoubleTap(const MultiTouchInput& aEvent)
+nsEventStatus GestureEventListener::HandleInputTouchCancel()
 {
-  TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_DOUBLE, aEvent.mTime,
-      aEvent.mTouches[0].mScreenPoint, aEvent.modifiers);
-  return mAsyncPanZoomController->HandleInputEvent(tapEvent);
+  SetState(GESTURE_NONE);
+  return nsEventStatus_eIgnore;
 }
 
-void GestureEventListener::TimeoutDoubleTap()
+void GestureEventListener::HandleInputTimeoutLongTap()
 {
-  mDoubleTapTimeoutTask = nullptr;
-  // If we haven't gotten another tap by now, reset the state and treat it as a
-  // single tap. It couldn't have been a double tap.
-  if (mState == GESTURE_WAITING_DOUBLE_TAP) {
-    mState = GESTURE_NONE;
+  mLongTapTimeoutTask = nullptr;
 
-    HandleSingleTapConfirmedEvent(mLastTouchInput);
+  switch (mState) {
+  case GESTURE_FIRST_SINGLE_TOUCH_DOWN:
+    // just in case MAX_TAP_TIME > ContextMenuDelay cancel MAX_TAP timer
+    // and fall through
+    CancelMaxTapTimeoutTask();
+  case GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN: {
+    SetState(GESTURE_LONG_TOUCH_DOWN);
+    TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_LONG,
+                             mLastTouchInput.mTime,
+                             mLastTouchInput.mTouches[0].mScreenPoint,
+                             mLastTouchInput.modifiers);
+    mAsyncPanZoomController->HandleGestureEvent(tapEvent);
+    break;
+  }
+  default:
+    NS_WARNING("Unhandled state upon long tap timeout");
+    SetState(GESTURE_NONE);
+    break;
   }
 }
 
-void GestureEventListener::CancelDoubleTapTimeoutTask() {
-  if (mDoubleTapTimeoutTask) {
-    mDoubleTapTimeoutTask->Cancel();
-    mDoubleTapTimeoutTask = nullptr;
+void GestureEventListener::HandleInputTimeoutMaxTap()
+{
+  mMaxTapTimeoutTask = nullptr;
+
+  if (mState == GESTURE_FIRST_SINGLE_TOUCH_DOWN) {
+    SetState(GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN);
+  } else if (mState == GESTURE_FIRST_SINGLE_TOUCH_UP ||
+             mState == GESTURE_SECOND_SINGLE_TOUCH_DOWN) {
+    SetState(GESTURE_NONE);
+    TriggerSingleTapConfirmedEvent();
+  } else {
+    NS_WARNING("Unhandled state upon MAX_TAP timeout");
+    SetState(GESTURE_NONE);
   }
 }
 
-void GestureEventListener::TimeoutLongTap()
+void GestureEventListener::TriggerSingleTapConfirmedEvent()
 {
-  mLongTapTimeoutTask = nullptr;
-  // If the tap has not been released, this is a long press.
-  if (mState == GESTURE_WAITING_SINGLE_TAP) {
-    mState = GESTURE_LONG_TAP_UP;
+  TapGestureInput tapEvent(TapGestureInput::TAPGESTURE_CONFIRMED,
+                           mLastTouchInput.mTime,
+                           mLastTouchInput.mTouches[0].mScreenPoint,
+                           mLastTouchInput.modifiers);
+  mAsyncPanZoomController->HandleGestureEvent(tapEvent);
+}
+
+void GestureEventListener::SetState(GestureState aState)
+{
+  mState = aState;
 
-    HandleLongTapEvent(mLastTouchInput);
+  if (mState == GESTURE_NONE) {
+    mSpanChange = 0.0f;
+    mPreviousSpan = 0.0f;
+  } else if (mState == GESTURE_MULTI_TOUCH_DOWN) {
+    mPreviousSpan = GetCurrentSpan(mLastTouchInput);
   }
 }
 
-void GestureEventListener::CancelLongTapTimeoutTask() {
+void GestureEventListener::CancelLongTapTimeoutTask()
+{
+  if (mState == GESTURE_SECOND_SINGLE_TOUCH_DOWN) {
+    // being in this state means the task has been canceled already
+    return;
+  }
+
   if (mLongTapTimeoutTask) {
     mLongTapTimeoutTask->Cancel();
     mLongTapTimeoutTask = nullptr;
   }
 }
 
-AsyncPanZoomController* GestureEventListener::GetAsyncPanZoomController() {
-  return mAsyncPanZoomController;
+void GestureEventListener::CreateLongTapTimeoutTask()
+{
+  mLongTapTimeoutTask =
+    NewRunnableMethod(this, &GestureEventListener::HandleInputTimeoutLongTap);
+
+  mAsyncPanZoomController->PostDelayedTask(
+    mLongTapTimeoutTask,
+    Preferences::GetInt("ui.click_hold_context_menus.delay", 500));
 }
 
-void GestureEventListener::CancelGesture() {
-  mTouches.Clear();
-  mState = GESTURE_NONE;
+void GestureEventListener::CancelMaxTapTimeoutTask()
+{
+  if (mState == GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN) {
+    // being in this state means the timer has just been triggered
+    return;
+  }
+
+  if (mMaxTapTimeoutTask) {
+    mMaxTapTimeoutTask->Cancel();
+    mMaxTapTimeoutTask = nullptr;
+  }
+}
+
+void GestureEventListener::CreateMaxTapTimeoutTask()
+{
+  mMaxTapTimeoutTask =
+    NewRunnableMethod(this, &GestureEventListener::HandleInputTimeoutMaxTap);
+
+  mAsyncPanZoomController->PostDelayedTask(
+    mMaxTapTimeoutTask,
+    MAX_TAP_TIME);
 }
 
 }
diff --git a/gfx/layers/ipc/GestureEventListener.h b/gfx/layers/ipc/GestureEventListener.h
index f655b43..703898b 100644
--- a/gfx/layers/ipc/GestureEventListener.h
+++ b/gfx/layers/ipc/GestureEventListener.h
@@ -7,10 +7,8 @@
 #ifndef mozilla_layers_GestureEventListener_h
 #define mozilla_layers_GestureEventListener_h
 
-#include <stdint.h>                     // for uint64_t
 #include "InputData.h"                  // for MultiTouchInput, etc
 #include "Units.h"                      // for ScreenIntPoint
-#include "mozilla/Assertions.h"         // for MOZ_ASSERT_HELPER2
 #include "mozilla/EventForwards.h"      // for nsEventStatus
 #include "nsAutoPtr.h"                  // for nsRefPtr
 #include "nsISupportsImpl.h"
@@ -54,123 +52,97 @@ public:
    * of a gesture, then we pass it along to AsyncPanZoomController. Otherwise,
    * it gets consumed here and never forwarded along.
    */
-  nsEventStatus HandleInputEvent(const InputData& aEvent);
+  nsEventStatus HandleInputEvent(const MultiTouchInput& aEvent);
 
-  /**
-   * Cancels any currently active gesture. May not properly handle situations
-   * that require extra work at the gesture's end, like a pinch which only
-   * requests a repaint once it has ended.
-   */
-  void CancelGesture();
+protected:
 
   /**
-   * Returns the AsyncPanZoomController stored on this class and used for
-   * callbacks.
+   * States of GEL finite-state machine.
    */
-  AsyncPanZoomController* GetAsyncPanZoomController();
-
-protected:
   enum GestureState {
-    // There's no gesture going on, and we don't think we're about to enter one.
+    // This is the initial and final state of any gesture.
+    // In this state there's no gesture going on, and we don't think we're
+    // about to enter one.
+    // Allowed next states: GESTURE_FIRST_SINGLE_TOUCH_DOWN, GESTURE_MULTI_TOUCH_DOWN.
     GESTURE_NONE,
+
+    // A touch start with a single touch point has just happened.
+    // After having gotten into this state we start timers for MAX_TAP_TIME and
+    // gfxPrefs::UiClickHoldContextMenusDelay().
+    // Allowed next states: GESTURE_MULTI_TOUCH_DOWN, GESTURE_NONE,
+    //                      GESTURE_FIRST_SINGLE_TOUCH_UP, GESTURE_LONG_TOUCH_DOWN,
+    //                      GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN.
+    GESTURE_FIRST_SINGLE_TOUCH_DOWN,
+
+    // While in GESTURE_FIRST_SINGLE_TOUCH_DOWN state a MAX_TAP_TIME timer got
+    // triggered. Now we'll trigger either a single tap if a user lifts her
+    // finger or a long tap if gfxPrefs::UiClickHoldContextMenusDelay() happens
+    // first.
+    // Allowed next states: GESTURE_MULTI_TOUCH_DOWN, GESTURE_NONE,
+    //                      GESTURE_LONG_TOUCH_DOWN.
+    GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN,
+
+    // A user put her finger down and lifted it up quickly enough.
+    // After having gotten into this state we clear the timer for MAX_TAP_TIME.
+    // Allowed next states: GESTURE_SECOND_SINGLE_TOUCH_DOWN, GESTURE_NONE,
+    //                      GESTURE_MULTI_TOUCH_DOWN.
+    GESTURE_FIRST_SINGLE_TOUCH_UP,
+
+    // A user put down her finger again right after a single tap thus the
+    // gesture can't be a single tap, but rather a double tap. But we're
+    // still not sure about that until the user lifts her finger again.
+    // Allowed next states: GESTURE_MULTI_TOUCH_DOWN, GESTURE_NONE.
+    GESTURE_SECOND_SINGLE_TOUCH_DOWN,
+
+    // A long touch has happened, but the user still keeps her finger down.
+    // We'll trigger a "long tap up" event when the finger is up.
+    // Allowed next states: GESTURE_NONE, GESTURE_MULTI_TOUCH_DOWN.
+    GESTURE_LONG_TOUCH_DOWN,
+
     // We have detected that two or more fingers are on the screen, but there
     // hasn't been enough movement yet to make us start actually zooming the
     // screen.
-    GESTURE_WAITING_PINCH,
+    // Allowed next states: GESTURE_PINCH, GESTURE_NONE
+    GESTURE_MULTI_TOUCH_DOWN,
+
     // There are two or more fingers on the screen, and the user has already
     // pinched enough for us to start zooming the screen.
-    GESTURE_PINCH,
-    // A touch start has happened and it may turn into a tap. We use this
-    // because, if we put down two fingers and then lift them very quickly, this
-    // may be mistaken for a tap.
-    GESTURE_WAITING_SINGLE_TAP,
-    // A single tap has happened for sure, and we're waiting for a second tap.
-    GESTURE_WAITING_DOUBLE_TAP,
-    // A long tap has happened, wait for the tap to be released in case we need
-    // to fire a click event in the case the long tap was not handled.
-    GESTURE_LONG_TAP_UP
+    // Allowed next states: GESTURE_NONE
+    GESTURE_PINCH
   };
 
   /**
-   * Attempts to handle the event as a pinch event. If it is not a pinch event,
-   * then we simply tell the next consumer to consume the event instead.
-   *
-   * |aClearTouches| marks whether or not to terminate any pinch currently
-   * happening.
-   */
-  nsEventStatus HandlePinchGestureEvent(const MultiTouchInput& aEvent, bool aClearTouches);
-
-  /**
-   * Attempts to handle the event as a single tap event, which highlights links
-   * before opening them. In general, this will not attempt to block the touch
-   * event from being passed along to AsyncPanZoomController since APZC needs to
-   * know about touches ending (and we only know if a touch was a tap once it
-   * ends).
+   * These HandleInput* functions comprise input alphabet of the GEL
+   * finite-state machine triggering state transitions.
    */
-  nsEventStatus HandleSingleTapUpEvent(const MultiTouchInput& aEvent);
+  nsEventStatus HandleInputTouchSingleStart();
+  nsEventStatus HandleInputTouchMultiStart();
+  nsEventStatus HandleInputTouchEnd();
+  nsEventStatus HandleInputTouchMove();
+  nsEventStatus HandleInputTouchCancel();
+  void HandleInputTimeoutLongTap();
+  void HandleInputTimeoutMaxTap();
 
-  /**
-   * Attempts to handle a single tap confirmation. This is what will actually
-   * open links, etc. In general, this will not attempt to block the touch event
-   * from being passed along to AsyncPanZoomController since APZC needs to know
-   * about touches ending (and we only know if a touch was a tap once it ends).
-   */
-  nsEventStatus HandleSingleTapConfirmedEvent(const MultiTouchInput& aEvent);
-
-  /**
-   * Attempts to handle a long tap confirmation. This is what will use
-   * for context menu.
-   */
-  nsEventStatus HandleLongTapEvent(const MultiTouchInput& aEvent);
-
-  /**
-   * Attempts to handle release of long tap. This is used to fire click
-   * events in the case the context menu was not invoked.
-   */
-  nsEventStatus HandleLongTapUpEvent(const MultiTouchInput& aEvent);
-
-  /**
-   * Attempts to handle a tap event cancellation. This happens when we think
-   * something was a tap but it actually wasn't. In general, this will not
-   * attempt to block the touch event from being passed along to
-   * AsyncPanZoomController since APZC needs to know about touches ending (and
-   * we only know if a touch was a tap once it ends).
-   */
-  nsEventStatus HandleTapCancel(const MultiTouchInput& aEvent);
+  void TriggerSingleTapConfirmedEvent();
 
   /**
-   * Attempts to handle a double tap. This happens when we get two single taps
-   * within a short time. In general, this will not attempt to block the touch
-   * event from being passed along to AsyncPanZoomController since APZC needs to
-   * know about touches ending (and we only know if a touch was a double tap
-   * once it ends).
+   * Do actual state transition and reset substates.
    */
-  nsEventStatus HandleDoubleTap(const MultiTouchInput& aEvent);
-
-  /**
-   * Times out a single tap we think may be turned into a double tap. This will
-   * also send a single tap if we're still in the "GESTURE_WAITING_DOUBLE_TAP"
-   * state when this is called. This should be called a short time after a
-   * single tap is detected, and the delay on it should be enough that the user
-   * has time to tap again (to make a double tap).
-   */
-  void TimeoutDoubleTap();
-  /**
-   * Times out a long tap. This should be called a 'long' time after a single
-   * tap is detected.
-   */
-  void TimeoutLongTap();
+  void SetState(GestureState aState);
 
   nsRefPtr<AsyncPanZoomController> mAsyncPanZoomController;
 
   /**
    * Array containing all active touches. When a touch happens it, gets added to
    * this array, even if we choose not to handle it. When it ends, we remove it.
+   * We need to maintain this array in order to detect the end of the
+   * "multitouch" states because touch start events contain all current touches,
+   * but touch end events contain only those touches that have gone.
    */
   nsTArray<SingleTouchData> mTouches;
 
   /**
-   * Current gesture we're dealing with.
+   * Current state we're dealing with.
    */
   GestureState mState;
 
@@ -189,56 +161,49 @@ protected:
   float mPreviousSpan;
 
   /**
-   * Stores the time a touch started, used for detecting a tap gesture. Only
-   * valid when there's exactly one touch in mTouches. This is the time that the
-   * first touch was inserted into the array. This is a uint64_t because it is
-   * initialized from interactions with InputData, which stores its timestamps as
-   * a uint64_t.
-   */
-  uint64_t mTapStartTime;
-
-  /**
-   * Stores the time the last tap ends (finger leaves the screen). This is used
-   * when mDoubleTapTimeoutTask cannot be scheduled in time and consecutive
-   * taps are falsely regarded as double taps.
-   */
-  uint64_t mLastTapEndTime;
-
-  /**
-   * Cached copy of the last touch input, only valid when in the
-   * "GESTURE_WAITING_DOUBLE_TAP" state. This is used to forward along to
-   * AsyncPanZoomController if a single tap needs to be sent (since it is sent
-   * shortly after the user actually taps, since we need to wait for a double
-   * tap).
+   * Cached copy of the last touch input.
    */
   MultiTouchInput mLastTouchInput;
 
   /**
-   * Task used to timeout a double tap. This gets posted to the UI thread such
-   * that it runs a short time after a single tap happens. We cache it so that
-   * we can cancel it if a double tap actually comes in.
-   * CancelDoubleTapTimeoutTask: Cancel the mDoubleTapTimeoutTask and also set
-   * it to null.
+   * Position of the last touch starting. This is only valid during an attempt
+   * to determine if a touch is a tap. If a touch point moves away from
+   * mTouchStartPosition to the distance greater than
+   * AsyncPanZoomController::GetTouchStartTolerance() while in
+   * GESTURE_FIRST_SINGLE_TOUCH_DOWN, GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN
+   * or GESTURE_SECOND_SINGLE_TOUCH_DOWN then we're certain the gesture is
+   * not tap.
    */
-  CancelableTask *mDoubleTapTimeoutTask;
-  inline void CancelDoubleTapTimeoutTask();
+  ScreenIntPoint mTouchStartPosition;
 
   /**
    * Task used to timeout a long tap. This gets posted to the UI thread such
    * that it runs a time when a single tap happens. We cache it so that
    * we can cancel it if any other touch event happens.
+   *
+   * The task is supposed to be non-null if in GESTURE_FIRST_SINGLE_TOUCH_DOWN
+   * and GESTURE_FIRST_SINGLE_TOUCH_MAX_TAP_DOWN states.
+   *
    * CancelLongTapTimeoutTask: Cancel the mLongTapTimeoutTask and also set
    * it to null.
    */
   CancelableTask *mLongTapTimeoutTask;
-  inline void CancelLongTapTimeoutTask();
+  void CancelLongTapTimeoutTask();
+  void CreateLongTapTimeoutTask();
 
   /**
-   * Position of the last touch starting. This is only valid during an attempt
-   * to determine if a touch is a tap. This means that it is used in both the
-   * "GESTURE_WAITING_SINGLE_TAP" and "GESTURE_WAITING_DOUBLE_TAP" states.
+   * Task used to timeout a single tap or a double tap.
+   *
+   * The task is supposed to be non-null if in GESTURE_FIRST_SINGLE_TOUCH_DOWN,
+   * GESTURE_FIRST_SINGLE_TOUCH_UP and GESTURE_SECOND_SINGLE_TOUCH_DOWN states.
+   *
+   * CancelMaxTapTimeoutTask: Cancel the mMaxTapTimeoutTask and also set
+   * it to null.
    */
-  ScreenIntPoint mTouchStartPosition;
+  CancelableTask *mMaxTapTimeoutTask;
+  void CancelMaxTapTimeoutTask();
+  void CreateMaxTapTimeoutTask();
+
 };
 
 }
