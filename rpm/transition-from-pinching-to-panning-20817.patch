diff --git a/gfx/layers/apz/src/APZCTreeManager.cpp b/gfx/layers/apz/src/APZCTreeManager.cpp
index 3fc4366..8cbe63d 100644
--- a/gfx/layers/apz/src/APZCTreeManager.cpp
+++ b/gfx/layers/apz/src/APZCTreeManager.cpp
@@ -601,6 +601,9 @@ APZCTreeManager::ProcessTouchInput(MultiTouchInput& aInput,
     mInOverscrolledApzc = false;
     mRetainedTouchIdentifier = -1;
     ClearOverscrollHandoffChain();
+  } else if (mTouchCount == 1 && mApzcForInputBlock && mOverscrollHandoffChain.length() == 0) {
+    // Now it may well be the start of panning after pinching.
+    BuildOverscrollHandoffChain(mApzcForInputBlock);
   }
 
   return result;
diff --git a/gfx/layers/apz/src/AsyncPanZoomController.cpp b/gfx/layers/apz/src/AsyncPanZoomController.cpp
index 99c59ec..c1c39e9 100644
--- a/gfx/layers/apz/src/AsyncPanZoomController.cpp
+++ b/gfx/layers/apz/src/AsyncPanZoomController.cpp
@@ -1278,6 +1278,21 @@ nsEventStatus AsyncPanZoomController::OnScaleEnd(const PinchGestureInput& aEvent
     UpdateSharedCompositorFrameMetrics();
   }
 
+  // Non-negative focus point would indicate that one finger is still down
+  if (aEvent.mFocusPoint.x != -1 && aEvent.mFocusPoint.y != -1) {
+    mPanDirRestricted = false;
+    mX.StartTouch(aEvent.mFocusPoint.x, aEvent.mTime);
+    mY.StartTouch(aEvent.mFocusPoint.y, aEvent.mTime);
+    APZCTreeManager* treeManagerLocal = mTreeManager;
+    nsRefPtr<GeckoContentController> controller = GetGeckoContentController();
+    if (treeManagerLocal && controller) {
+      bool touchCanBePan = treeManagerLocal->CanBePanned(this);
+      controller->NotifyAPZStateChange(
+        GetGuid(), APZStateChange::StartTouch, touchCanBePan);
+    }
+    SetState(TOUCHING);
+  }
+
   return nsEventStatus_eConsumeNoDefault;
 }
 
diff --git a/gfx/layers/apz/src/GestureEventListener.cpp b/gfx/layers/apz/src/GestureEventListener.cpp
index 47f012f..0f33e8f 100644
--- a/gfx/layers/apz/src/GestureEventListener.cpp
+++ b/gfx/layers/apz/src/GestureEventListener.cpp
@@ -357,10 +357,16 @@ nsEventStatus GestureEventListener::HandleInputTouchEnd()
   case GESTURE_PINCH:
     if (mTouches.Length() < 2) {
       SetState(GESTURE_NONE);
+      ScreenPoint point(-1, -1);
+      if (mTouches.Length() == 1) {
+        // As user still keeps one finger down the event's focus point should
+        // contain meaningful data.
+        point = mTouches[0].mScreenPoint;
+      }
       PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_END,
                                    mLastTouchInput.mTime,
                                    mLastTouchInput.mTimeStamp,
-                                   ScreenPoint(),
+                                   point,
                                    1.0f,
                                    1.0f,
                                    mLastTouchInput.modifiers);
