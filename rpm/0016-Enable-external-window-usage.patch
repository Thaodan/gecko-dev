From 0dcf163d37e0576b611545218d47dd7b206dd8eb Mon Sep 17 00:00:00 2001
From: Dmitry Rozhkov <dmitry.rozhkov@jolla.com>
Date: Mon, 11 May 2015 15:27:51 +0300
Subject: [PATCH 1/3] Enable external window usage

---
 gfx/gl/GLContextProviderEGL.cpp     | 15 ++++++++++-
 gfx/layers/opengl/CompositorOGL.cpp | 52 ++++++++++++++++++++++++++++++++++---
 gfx/layers/opengl/CompositorOGL.h   |  2 ++
 gfx/thebes/gfxPrefs.h               |  1 +
 4 files changed, 66 insertions(+), 4 deletions(-)

diff --git a/gfx/gl/GLContextProviderEGL.cpp b/gfx/gl/GLContextProviderEGL.cpp
index e6d89bf..7975a3b 100644
--- a/gfx/gl/GLContextProviderEGL.cpp
+++ b/gfx/gl/GLContextProviderEGL.cpp
@@ -101,6 +101,7 @@ public:
 #include "gfxFailure.h"
 #include "gfxASurface.h"
 #include "gfxPlatform.h"
+#include "gfxPrefs.h"
 #include "GLContextProvider.h"
 #include "GLLibraryEGL.h"
 #include "TextureImageEGL.h"
@@ -416,7 +417,13 @@ GLContextEGL::IsCurrent() {
 bool
 GLContextEGL::RenewSurface() {
     if (!mOwnsContext) {
-        return false;
+        if (gfxPrefs::UseExternalWindow()) {
+            mSurface = sEGLLibrary.fGetCurrentSurface(LOCAL_EGL_DRAW);
+            MOZ_ASSERT(mSurface != EGL_NO_SURFACE);
+            return MakeCurrent(true);
+        } else {
+            return false;
+        }
     }
 #ifndef MOZ_WIDGET_ANDROID
     MOZ_CRASH("unimplemented");
@@ -700,6 +707,12 @@ GLContextProviderEGL::CreateWrappingExisting(void* aContext, void* aSurface)
         return nullptr;
     }
 
+    if (gfxPrefs::UseExternalWindow()) {
+        // TODO as soon context and surface guaranteed to be non-null
+        aSurface = aSurface ? aSurface : sEGLLibrary.fGetCurrentSurface(LOCAL_EGL_DRAW);
+        aContext = aContext ? aContext : sEGLLibrary.fGetCurrentContext();
+    }
+
     if (aContext && aSurface) {
         SurfaceCaps caps = SurfaceCaps::Any();
         EGLConfig config = EGL_NO_CONFIG;
diff --git a/gfx/layers/opengl/CompositorOGL.cpp b/gfx/layers/opengl/CompositorOGL.cpp
index c12d381..fd30aa1 100644
--- a/gfx/layers/opengl/CompositorOGL.cpp
+++ b/gfx/layers/opengl/CompositorOGL.cpp
@@ -161,6 +161,7 @@ CompositorOGL::CompositorOGL(nsIWidget *aWidget, int aSurfaceWidth,
   , mUseExternalSurfaceSize(aUseExternalSurfaceSize)
   , mFrameInProgress(false)
   , mDestroyed(false)
+  , mPaused(false)
   , mHeight(0)
 {
   MOZ_COUNT_CTOR(CompositorOGL);
@@ -185,6 +186,17 @@ CompositorOGL::CreateContext()
   }
 #endif
 
+  // If widget has active GL context then we can try to wrap it into Moz GL Context.
+  // Allow widget to create opengl context for the compositor thread and
+  // using surface of an external window.
+  if (gfxPrefs::UseExternalWindow() && mWidget->HasGLContext()) {
+    context = GLContextProvider::CreateWrappingExisting(nullptr, nullptr);
+    if (!context || !context->Init()) {
+      NS_WARNING("Failed to create embedded context");
+      context = nullptr;
+    }
+  }
+
   // Allow to create offscreen GL context for main Layer Manager
   if (!context && PR_GetEnv("MOZ_LAYERS_PREFER_OFFSCREEN")) {
     SurfaceCaps caps = SurfaceCaps::ForRGB();
@@ -1392,28 +1404,62 @@ CompositorOGL::CopyToTarget(DrawTarget *aTarget, const gfx::Matrix& aTransform)
 void
 CompositorOGL::Pause()
 {
-#ifdef MOZ_WIDGET_ANDROID
-  if (!gl() || gl()->IsDestroyed())
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_QT)
+  if (!gl() || gl()->IsDestroyed() || !gfxPrefs::UseExternalWindow())
     return;
 
+  if (mFrameInProgress) {
+    // The browser may request compositor pause when actual compositing is
+    // in progress. Make sure we abort this process.
+    AbortFrame();
+  }
   // ReleaseSurface internally calls MakeCurrent.
   gl()->ReleaseSurface();
+
+  mPaused = true;
 #endif
 }
 
 bool
 CompositorOGL::Resume()
 {
-#ifdef MOZ_WIDGET_ANDROID
+#if defined(MOZ_WIDGET_ANDROID) || defined(MOZ_WIDGET_QT)
+  if (!gfxPrefs::UseExternalWindow())
+    return true;
+
   if (!gl() || gl()->IsDestroyed())
     return false;
 
+  if (gfxPrefs::UseExternalWindow()) {
+    realGLboolean scissorTestEnabled;
+    gl()->fGetBooleanv(LOCAL_GL_SCISSOR_TEST, &scissorTestEnabled);
+    if (scissorTestEnabled) {
+      // Reset scissor box that might have been left behind by previous
+      // compositor instance operating on the same window surface. Take into
+      // account cached scissor box stored inside GLContext::mScissorRect may
+      // actually be of mWidgetSize which would make the call a noop.
+      gl()->fScissor(0, 0, mWidgetSize.width - 1, mWidgetSize.height - 1);
+      gl()->fScissor(0, 0, mWidgetSize.width, mWidgetSize.height);
+    }
+  }
+
+  mPaused = false;
+
   // RenewSurface internally calls MakeCurrent.
   return gl()->RenewSurface();
 #endif
   return true;
 }
 
+bool
+CompositorOGL::Ready()
+{
+  if (gfxPrefs::UseExternalWindow() && mPaused) {
+    return false;
+  }
+  return Compositor::Ready();
+}
+
 TemporaryRef<DataTextureSource>
 CompositorOGL::CreateDataTextureSource(TextureFlags aFlags)
 {
diff --git a/gfx/layers/opengl/CompositorOGL.h b/gfx/layers/opengl/CompositorOGL.h
index 97b6c14..416e49e 100644
--- a/gfx/layers/opengl/CompositorOGL.h
+++ b/gfx/layers/opengl/CompositorOGL.h
@@ -259,6 +259,7 @@ public:
 
   virtual void Pause() MOZ_OVERRIDE;
   virtual bool Resume() MOZ_OVERRIDE;
+  virtual bool Ready() MOZ_OVERRIDE;
 
   virtual nsIWidget* GetWidget() const MOZ_OVERRIDE { return mWidget; }
 
@@ -410,6 +411,7 @@ private:
   RefPtr<CompositorTexturePoolOGL> mTexturePool;
 
   bool mDestroyed;
+  bool mPaused;
 
   /**
    * Height of the OpenGL context's primary framebuffer in pixels. Used by
diff --git a/gfx/thebes/gfxPrefs.h b/gfx/thebes/gfxPrefs.h
index 9b102b7..825a740 100644
--- a/gfx/thebes/gfxPrefs.h
+++ b/gfx/thebes/gfxPrefs.h
@@ -140,6 +140,7 @@ private:
   DECL_GFX_PREF(Once, "gfx.canvas.skiagl.cache-items",         CanvasSkiaGLCacheItems, int32_t, 256);
 
   DECL_GFX_PREF(Once, "gfx.compositor.clear-context",          ClearCompoisitorContext, bool, true);
+  DECL_GFX_PREF(Once, "gfx.compositor.external-window",        UseExternalWindow, bool, false);
 
   DECL_GFX_PREF(Live, "gfx.color_management.enablev4",         CMSEnableV4, bool, false);
   DECL_GFX_PREF(Live, "gfx.color_management.mode",             CMSMode, int32_t,-1);
-- 
2.3.6

