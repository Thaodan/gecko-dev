diff --git a/embedding/embedlite/embedthread/EmbedLiteViewThreadChild.cpp b/embedding/embedlite/embedthread/EmbedLiteViewThreadChild.cpp
index 53acf22..a49e55b 100644
--- a/embedding/embedlite/embedthread/EmbedLiteViewThreadChild.cpp
+++ b/embedding/embedlite/embedthread/EmbedLiteViewThreadChild.cpp
@@ -643,6 +643,7 @@ EmbedLiteViewThreadChild::RecvAcknowledgeScrollUpdate(const FrameMetrics::ViewID
     return true;
   }
 
+  mHelper->mLastRootMetrics.SetScrollOffset(CSSPoint(-1, -1));
   APZCCallbackHelper::AcknowledgeScrollUpdate(aScrollId, aScrollGeneration);
 
   return true;
diff --git a/gfx/layers/apz/util/APZCCallbackHelper.cpp b/gfx/layers/apz/util/APZCCallbackHelper.cpp
index d960007..11407a4 100644
--- a/gfx/layers/apz/util/APZCCallbackHelper.cpp
+++ b/gfx/layers/apz/util/APZCCallbackHelper.cpp
@@ -83,7 +83,7 @@ ScrollFrameTo(nsIScrollableFrame* aFrame, const CSSPoint& aPoint, bool& aSuccess
   // Also if the scrollable frame got a scroll request from something other than us
   // since the last layers update, then we don't want to push our scroll request
   // because we'll clobber that one, which is bad.
-  if (!aFrame->IsProcessingAsyncScroll() &&
+  if (!aFrame->IsProcessingAsyncScroll() && (targetScrollPosition.x != -1 && targetScrollPosition.y != -1) &&
      (!aFrame->OriginOfLastScroll() || aFrame->OriginOfLastScroll() == nsGkAtoms::apz)) {
     aFrame->ScrollToCSSPixelsApproximate(targetScrollPosition, nsGkAtoms::apz);
     geckoScrollPosition = CSSPoint::FromAppUnits(aFrame->GetScrollPosition());
@@ -119,13 +119,14 @@ APZCCallbackHelper::UpdateRootFrame(nsIDOMWindowUtils* aUtils,
     // Scroll the window to the desired spot
     nsIScrollableFrame* sf = nsLayoutUtils::FindScrollableFrameFor(aMetrics.GetScrollId());
     bool scrollUpdated = false;
-    CSSPoint actualScrollOffset = ScrollFrameTo(sf, aMetrics.GetScrollOffset(), scrollUpdated);
+    CSSPoint currentScrollOffset = aMetrics.GetScrollOffset();
+    CSSPoint actualScrollOffset = ScrollFrameTo(sf, currentScrollOffset, scrollUpdated);
 
     if (scrollUpdated) {
         // Correct the display port due to the difference between mScrollOffset and the
         // actual scroll offset.
         AdjustDisplayPortForScrollDelta(aMetrics, actualScrollOffset);
-    } else {
+    } else if (currentScrollOffset.x != -1 && currentScrollOffset.y != -1) {
         // For whatever reason we couldn't update the scroll offset on the scroll frame,
         // which means the data APZ used for its displayport calculation is stale. Fall
         // back to a sane default behaviour. Note that we don't tile-align the recentered
