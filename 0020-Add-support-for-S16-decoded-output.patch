From af8b24d7c1bee570eee1f8695c7ad954eb5eb489 Mon, 1 Jun 2020 19:42:55 +0200
From: Jean-Yves Avenard <jyavenard@mozilla.com>
Date: Wed, 1 Nov 2017 11:33:06 +0100
Subject: [PATCH] Bug 1295886 - P7. Add support for S16 decoded output. r=gerald


Android audio backend only supports S16 audio sample, so configure ffmpeg audio decoder to output 16 bits audio by default. Adding format conversions as necessary.

Backport from ESR60

MozReview-Commit-ID: J6N4rbMZ3Ug

--HG--
extra : rebase_source : 7a8a72a7e9cd3dde2c8659d363875c6d5072b6b2

diff --git a/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp b/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
index 6d2098f..4691254 100644
--- a/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
+++ b/dom/media/platforms/ffmpeg/FFmpegAudioDecoder.cpp
@@ -48,8 +48,12 @@
   mCodecContext->thread_count = 1;
   // FFmpeg takes this as a suggestion for what format to use for audio samples.
   // LibAV 0.8 produces rubbish float interleaved samples, request 16 bits audio.
+#ifdef MOZ_SAMPLE_TYPE_S16
+  mCodecContext->request_sample_fmt = AV_SAMPLE_FMT_S16;
+#else
   mCodecContext->request_sample_fmt =
     (mLib->mVersion == 53) ? AV_SAMPLE_FMT_S16 : AV_SAMPLE_FMT_FLT;
+#endif
 }
 
 static AlignedAudioBuffer
@@ -62,6 +66,62 @@
     return audio;
   }
 
+#ifdef MOZ_SAMPLE_TYPE_S16
+  if (aFrame->format == AV_SAMPLE_FMT_FLT) {
+    // Audio data already packed. Need to convert from 32 bits Float to S16
+    AudioDataValue* tmp = audio.get();
+    float* data = reinterpret_cast<float**>(aFrame->data)[0];
+    for (uint32_t frame = 0; frame < aNumAFrames; frame++) {
+      for (uint32_t channel = 0; channel < aNumChannels; channel++) {
+        *tmp++ = FloatToAudioSample<int16_t>(*data++);
+      }
+    }
+  } else if (aFrame->format == AV_SAMPLE_FMT_FLTP) {
+    // Planar audio data. Convert it from 32 bits float to S16
+    // and pack it into something we can understand.
+    AudioDataValue* tmp = audio.get();
+    float** data = reinterpret_cast<float**>(aFrame->data);
+    for (uint32_t frame = 0; frame < aNumAFrames; frame++) {
+      for (uint32_t channel = 0; channel < aNumChannels; channel++) {
+        *tmp++ = FloatToAudioSample<int16_t>(data[channel][frame]);
+      }
+    }
+  } else if (aFrame->format == AV_SAMPLE_FMT_S16) {
+    // Audio data already packed. No need to do anything other than copy it
+    // into a buffer we own.
+    memcpy(audio.get(),
+           aFrame->data[0],
+           aNumChannels * aNumAFrames * sizeof(AudioDataValue));
+  } else if (aFrame->format == AV_SAMPLE_FMT_S16P) {
+    // Planar audio data. Pack it into something we can understand.
+    AudioDataValue* tmp = audio.get();
+    AudioDataValue** data = reinterpret_cast<AudioDataValue**>(aFrame->data);
+    for (uint32_t frame = 0; frame < aNumAFrames; frame++) {
+      for (uint32_t channel = 0; channel < aNumChannels; channel++) {
+        *tmp++ = data[channel][frame];
+      }
+    }
+  } else if (aFrame->format == AV_SAMPLE_FMT_S32) {
+    // Audio data already packed. Need to convert from S32 to S16
+    AudioDataValue* tmp = audio.get();
+    int32_t* data = reinterpret_cast<int32_t**>(aFrame->data)[0];
+    for (uint32_t frame = 0; frame < aNumAFrames; frame++) {
+      for (uint32_t channel = 0; channel < aNumChannels; channel++) {
+        *tmp++ = *data++ / (1U<<16);
+      }
+    }
+  } else if (aFrame->format == AV_SAMPLE_FMT_S32P) {
+    // Planar audio data. Convert it from S32 to S16
+    // and pack it into something we can understand.
+    AudioDataValue* tmp = audio.get();
+    int32_t** data = reinterpret_cast<int32_t**>(aFrame->data);
+    for (uint32_t frame = 0; frame < aNumAFrames; frame++) {
+      for (uint32_t channel = 0; channel < aNumChannels; channel++) {
+        *tmp++ = data[channel][frame] / (1U<<16);
+      }
+    }
+  }
+#else
   if (aFrame->format == AV_SAMPLE_FMT_FLT) {
     // Audio data already packed. No need to do anything other than copy it
     // into a buffer we own.
@@ -115,6 +175,7 @@
       }
     }
   }
+#endif
 
   return audio;
 }
